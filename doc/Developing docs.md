### **1. 开发流程**

#### **1.1 需求分析**
- **明确功能需求**：
  - 模拟水体流动（基于Navier-Stokes方程）。
  - 添加鱼类，能够根据水流方向游动。
  - 添加半透明小球，支持与水体的物理交互（如浮力、密度影响）。
  - 实现简单的光线追踪效果（如阴影、反射等）。
  - 用户可以通过界面投放小球或观察模拟过程。
- **技术选型**：
  - 使用C++作为编程语言。
  - 使用Qt框架管理窗口和事件循环。
  - 使用OpenGL进行图形渲染和光线追踪效果模拟。
  - 使用有限差分法实现流体模拟。

#### **1.2 系统设计**
- **模块划分**：
  - **流体模拟模块**：负责计算水体的速度场和压力场。
  - **物体模块**：包括鱼类和小球，负责它们的运动逻辑和与水体的交互。
  - **渲染模块**：使用OpenGL绘制水体、鱼类、小球，并实现光线追踪效果。
  - **主控模块**：负责协调各个模块的运行，处理用户输入和更新模拟状态。
- **数据流设计**：
  - 流体模拟模块生成速度场。
  - 物体模块根据速度场更新位置。
  - 渲染模块根据物体的位置和流体的状态绘制场景。
- **性能优化考虑**：
  - 使用空间分区（如网格）加速流体与物体的交互计算。
  - 对OpenGL渲染进行优化，避免不必要的重绘。

#### **1.3 开发阶段**
1. **搭建基础框架**：
   - 使用Qt创建主窗口，初始化OpenGL上下文。
   - 设置定时器用于定期更新模拟状态。
2. **实现流体模拟模块**：
   - 编写有限差分法求解Navier-Stokes方程。
   - 测试并验证流体模拟结果。
3. **实现物体模块**：
   - 定义鱼类和小球类，实现它们的运动逻辑。
   - 让鱼类和小球根据流体速度场更新位置。
4. **实现渲染模块**：
   - 绘制流体的速度场（如箭头或粒子效果）。
   - 绘制鱼类和小球，支持半透明效果。
   - 添加简单的光线追踪效果（如阴影、反射）。
5. **集成与调试**：
   - 将各模块整合到主控模块中。
   - 调试各模块之间的交互，确保逻辑正确。
6. **优化与扩展**：
   - 优化性能，减少计算和渲染开销。
   - 添加更多功能，如用户交互（投放小球）、更复杂的光线追踪效果等。

#### **1.4 测试与发布**
- **单元测试**：
  - 对每个模块单独进行测试，确保其功能正常。
- **集成测试**：
  - 测试模块之间的交互，确保整体功能符合预期。
- **用户测试**：
  - 邀请用户试用，收集反馈并改进。
- **发布版本**：
  - 打包程序，提供安装说明和文档。

---

### **2. 程序结构**

#### **2.1 模块划分**
程序可以划分为以下几个模块：

1. **主控模块**：
   - 负责程序的整体运行。
   - 初始化各个模块，处理用户输入，调度模拟更新和渲染。

2. **流体模拟模块**：
   - 核心功能是求解Navier-Stokes方程，生成水体的速度场和压力场。
   - 提供接口供其他模块获取当前的流体状态。

3. **物体模块**：
   - 包括鱼类和小球两个子模块。
   - **鱼类**：根据流体速度场更新位置，模拟游动行为。
   - **小球**：根据流体速度场和自身的密度属性，模拟浮力和运动。

4. **渲染模块**：
   - 使用OpenGL绘制水体、鱼类和小球。
   - 支持半透明效果和简单的光线追踪（如阴影、反射）。

5. **用户交互模块**：
   - 处理用户输入（如鼠标点击投放小球）。
   - 提供UI界面（如按钮、滑块）供用户调整参数。

---

#### **2.2 数据结构**
以下是主要的数据结构及其用途：

1. **流体数据**：
   - `std::vector<std::array<float, 2>> velocity_field`: 存储流体的速度场（二维数组）。
   - `std::vector<float> pressure_field`: 存储流体的压力场（可选）。

2. **物体数据**：
   - **鱼类**：
     - `std::array<float, 2> position`: 当前位置。
     - `std::array<float, 2> velocity`: 当前速度。
   - **小球**：
     - `std::array<float, 2> position`: 当前位置。
     - `float radius`: 半径。
     - `float density`: 密度。
     - `std::array<float, 2> velocity`: 当前速度。

3. **渲染数据**：
   - OpenGL相关的顶点缓冲区、纹理、着色器等。

---

#### **2.3 接口设计**
以下是各模块之间的接口设计：

1. **流体模拟模块接口**：
   - `void update()`: 更新流体状态。
   - `const std::vector<std::array<float, 2>>& get_velocity_field() const`: 获取当前速度场。

2. **物体模块接口**：
   - **鱼类**：
     - `void update(const std::vector<std::array<float, 2>>& velocity_field)`: 根据流体速度场更新位置。
     - `std::array<float, 2> getPosition() const`: 获取当前位置。
   - **小球**：
     - `void update(const std::vector<std::array<float, 2>>& velocity_field)`: 根据流体速度场更新位置。
     - `std::array<float, 2> getPosition() const`: 获取当前位置。
     - `float getRadius() const`: 获取半径。
     - `float getDensity() const`: 获取密度。

3. **渲染模块接口**：
   - `void initializeGL()`: 初始化OpenGL环境。
   - `void resizeGL(int width, int height)`: 处理窗口大小变化。
   - `void paintGL()`: 绘制场景。
   - `void drawFluid(const std::vector<std::array<float, 2>>& velocity_field)`: 绘制流体。
   - `void drawFish(const Fish& fish)`: 绘制鱼类。
   - `void drawBall(const Ball& ball)`: 绘制小球。

4. **主控模块接口**：
   - `void startSimulation()`: 启动模拟。
   - `void stopSimulation()`: 停止模拟。
   - `void handleUserInput()`: 处理用户输入。

---

#### **2.4 控制流程**
1. **初始化**：
   - 创建流体模拟器、鱼类、小球和渲染器实例。
   - 初始化OpenGL上下文。

2. **主循环**：
   - **更新阶段**：
     - 调用流体模拟器的`update()`方法更新流体状态。
     - 调用鱼类和小球的`update()`方法更新它们的位置。
   - **渲染阶段**：
     - 调用渲染器的`paintGL()`方法绘制场景。
   - **用户输入处理**：
     - 检测用户输入（如鼠标点击），投放小球或调整参数。

3. **退出**：
   - 释放资源，关闭程序。

### **2. 更适合的架构：组件化架构**

#### **2.1 组件化架构的基本概念**
组件化架构将程序划分为多个独立的模块（或组件），每个模块专注于完成特定的功能。这些模块之间通过明确的接口进行通信，但彼此保持松耦合。

#### **2.2 在本项目中的应用**
以下是基于组件化架构的模块划分：

1. **核心模块**：
   - **职责**：负责程序的整体运行。
   - **实现**：主循环、模块初始化和调度。
   - **示例**：`MainController`类。

2. **流体模拟模块**：
   - **职责**：计算水体的速度场和压力场。
   - **实现**：`FluidSimulator`类。
   - **接口**：
     - `void update()`: 更新流体状态。
     - `const std::vector<std::array<float, 2>>& get_velocity_field() const`: 获取速度场。

3. **物体模块**：
   - **职责**：管理鱼类和小球的行为。
   - **实现**：
     - `Fish`类：根据流体速度场更新位置。
     - `Ball`类：根据流体速度场和密度属性更新位置。
   - **接口**：
     - `void update(const std::vector<std::array<float, 2>>& velocity_field)`: 更新位置。
     - `std::array<float, 2> getPosition() const`: 获取当前位置。

4. **渲染模块**：
   - **职责**：使用OpenGL绘制场景。
   - **实现**：`Renderer`类。
   - **接口**：
     - `void initializeGL()`: 初始化OpenGL环境。
     - `void paintGL()`: 绘制场景。
     - `void drawFluid(const std::vector<std::array<float, 2>>& velocity_field)`: 绘制流体。
     - `void drawFish(const Fish& fish)`: 绘制鱼类。
     - `void drawBall(const Ball& ball)`: 绘制小球。

5. **用户交互模块**：
   - **职责**：处理用户输入。
   - **实现**：`UserInputHandler`类。
   - **接口**：
     - `void handleMouseClick(float x, float y)`: 处理鼠标点击事件。
     - `void handleKeyPress(int key)`: 处理键盘输入。

#### **2.3 组件化架构的优点**
- **模块化**：每个模块专注于单一功能，便于开发、测试和维护。
- **灵活性**：可以根据需求轻松替换或扩展某个模块（如更换渲染引擎或改进流体模拟算法）。
- **高性能**：避免了MVC中不必要的抽象层，可以直接在主循环中调用各模块的接口，确保实时性。

#### **2.4 示例结构**
```
project/
├── core/
│   ├── MainController.h
│   └── MainController.cpp
├── fluid/
│   ├── FluidSimulator.h
│   └── FluidSimulator.cpp
├── objects/
│   ├── Fish.h
│   ├── Fish.cpp
│   ├── Ball.h
│   └── Ball.cpp
├── renderer/
│   ├── Renderer.h
│   └── Renderer.cpp
├── input/
│   ├── UserInputHandler.h
│   └── UserInputHandler.cpp
└── main.cpp
```

### **4. 推荐架构**

综合考虑项目的规模和需求，推荐使用**组件化架构**，并在必要时结合MVC的思想（如在用户界面部分）。以下是具体建议：

1. **核心模块**：负责主循环和模块调度。
2. **流体模拟模块**：独立实现流体计算。
3. **物体模块**：管理鱼类和小球的行为。
4. **渲染模块**：使用OpenGL绘制场景。
5. **用户交互模块**：处理用户输入。

### **1. 开发流程**

#### **1.1 需求分析**
- **明确功能需求**：
  - **水体模拟**：基于Navier-Stokes方程，模拟二维不可压缩流体。
    - 水体流动（速度场）。
    - 边界条件（如壁面无滑移、自由表面等）。
  - **鱼类**：
    - 根据水流方向游动。
    - 可以设置初始位置、速度。
  - **小球**：
    - 半透明效果。
    - 支持与水体的物理交互（浮力、密度影响）。
    - 用户可以通过界面投放小球。
  - **光线追踪效果**：
    - 简单的阴影效果（如小球在水底投射阴影）。
    - 反射效果（可选）。
  - **用户交互**：
    - 通过鼠标点击投放小球。
    - 调整参数（如小球密度、流体黏性等）。
- **技术选型**：
  - 使用C++作为编程语言。
  - 使用Qt框架管理窗口和事件循环。
  - 使用OpenGL进行图形渲染。
  - 使用有限差分法实现流体模拟。

#### **1.2 系统设计**
- **模块划分**：
  - **主控模块**：
    - 负责初始化各个模块。
    - 处理用户输入（如投放小球）。
    - 调度模拟更新和渲染。
  - **流体模拟模块**：
    - 计算水体的速度场和压力场。
    - 提供接口供其他模块获取流体状态。
  - **物体模块**：
    - 包括鱼类和小球两个子模块。
    - 负责它们的运动逻辑和与水体的交互。
  - **渲染模块**：
    - 使用OpenGL绘制水体、鱼类、小球。
    - 实现半透明效果和简单的光线追踪（如阴影、反射）。
  - **用户交互模块**：
    - 处理用户输入（如鼠标点击投放小球）。
    - 提供UI界面（如按钮、滑块）供用户调整参数。

---

### **2. 程序结构**

#### **2.1 主控模块**
- **职责**：
  - 初始化所有模块。
  - 处理用户输入。
  - 调度模拟更新和渲染。
- **关键逻辑**：
  1. **初始化**：
     - 创建`FluidSimulator`实例。
     - 创建`Fish`和`Ball`实例。
     - 初始化OpenGL上下文。
  2. **主循环**：
     - **更新阶段**：
       - 调用`FluidSimulator::update()`更新流体状态。
       - 调用`Fish::update()`和`Ball::update()`更新物体位置。
     - **渲染阶段**：
       - 调用`Renderer::paintGL()`绘制场景。
     - **用户输入处理**：
       - 检测鼠标点击事件，创建新的小球。
       - 检测键盘输入，调整参数（如暂停/继续模拟）。
  3. **退出**：
     - 释放资源，关闭程序。

---

#### **2.2 流体模拟模块**
- **职责**：
  - 基于Navier-Stokes方程计算水体的速度场和压力场。
  - 提供接口供其他模块获取流体状态。
- **数据结构**：
  - `std::vector<std::array<float, 2>> velocity_field`: 存储速度场。
  - `std::vector<float> pressure_field`: 存储压力场（可选）。
- **关键逻辑**：
  1. **初始化**：
     - 设置网格大小（`nx`, `ny`）、时间步长（`dt`）、空间步长（`dx`, `dy`）、黏性系数（`nu`）。
     - 初始化速度场和压力场。
  2. **更新**：
     - 使用有限差分法求解Navier-Stokes方程：
       - 对流项（advection term）。
       - 扩散项（diffusion term）。
       - 压力项（pressure term）。
     - 应用边界条件（如壁面无滑移、自由表面等）。
  3. **接口**：
     - `void update()`: 更新流体状态。
     - `const std::vector<std::array<float, 2>>& get_velocity_field() const`: 获取当前速度场。

---

#### **2.3 物体模块**
- **鱼类**：
  - **职责**：
    - 根据流体速度场更新位置。
    - 模拟游动行为。
  - **数据结构**：
    - `std::array<float, 2> position`: 当前位置。
    - `std::array<float, 2> velocity`: 当前速度。
  - **关键逻辑**：
    1. **初始化**：
       - 设置初始位置和速度。
    2. **更新**：
       - 根据当前位置插值获取流体速度。
       - 更新位置：`position += velocity * dt`。
    3. **接口**：
       - `void update(const std::vector<std::array<float, 2>>& velocity_field)`: 更新位置。
       - `std::array<float, 2> getPosition() const`: 获取当前位置。

- **小球**：
  - **职责**：
    - 根据流体速度场和自身的密度属性，模拟浮力和运动。
    - 支持用户投放。
  - **数据结构**：
    - `std::array<float, 2> position`: 当前位置。
    - `float radius`: 半径。
    - `float density`: 密度。
    - `std::array<float, 2> velocity`: 当前速度。
  - **关键逻辑**：
    1. **初始化**：
       - 设置初始位置、半径和密度。
    2. **更新**：
       - 根据当前位置插值获取流体速度。
       - 计算浮力：`buoyancy = (fluid_density - ball_density) * gravity`。
       - 更新速度：`velocity += buoyancy * dt + fluid_velocity`。
       - 更新位置：`position += velocity * dt`。
    3. **接口**：
       - `void update(const std::vector<std::array<float, 2>>& velocity_field)`: 更新位置。
       - `std::array<float, 2> getPosition() const`: 获取当前位置。
       - `float getRadius() const`: 获取半径。
       - `float getDensity() const`: 获取密度。

---

#### **2.4 渲染模块**
- **职责**：
  - 使用OpenGL绘制水体、鱼类、小球。
  - 实现半透明效果和简单的光线追踪（如阴影、反射）。
- **关键逻辑**：
  1. **初始化**：
     - 初始化OpenGL上下文。
     - 加载着色器（shader）。
     - 设置混合模式（`glBlendFunc`）以支持半透明效果。
  2. **绘制水体**：
     - 绘制速度场（如箭头或粒子效果）。
     - 使用颜色渐变表示速度大小。
  3. **绘制鱼类**：
     - 使用点或简单形状表示鱼类。
  4. **绘制小球**：
     - 使用三角形扇（`GL_TRIANGLE_FAN`）绘制圆形。
     - 设置颜色和透明度。
     - 添加阴影效果：
       - 在小球下方绘制一个偏移的深色圆形。
  5. **接口**：
     - `void initializeGL()`: 初始化OpenGL环境。
     - `void resizeGL(int width, int height)`: 处理窗口大小变化。
     - `void paintGL()`: 绘制场景。
     - `void drawFluid(const std::vector<std::array<float, 2>>& velocity_field)`: 绘制流体。
     - `void drawFish(const Fish& fish)`: 绘制鱼类。
     - `void drawBall(const Ball& ball)`: 绘制小球。

---

#### **2.5 用户交互模块**
- **职责**：
  - 处理用户输入（如鼠标点击投放小球）。
  - 提供UI界面（如按钮、滑块）供用户调整参数。
- **关键逻辑**：
  1. **鼠标点击**：
     - 检测鼠标点击事件，获取点击位置。
     - 创建新的小球实例，并将其添加到场景中。
  2. **键盘输入**：
     - 检测键盘输入（如按下空格键暂停/继续模拟）。
  3. **UI界面**：
     - 使用Qt的`QPushButton`、`QSlider`等控件创建界面。
     - 提供滑块调整参数（如小球密度、流体黏性等）。

---

### **3. 控制流程**

1. **初始化**：
   - 创建`FluidSimulator`实例。
   - 创建`Fish`和`Ball`实例。
   - 初始化OpenGL上下文。
   - 创建用户界面（如按钮、滑块）。

2. **主循环**：
   - **更新阶段**：
     - 调用`FluidSimulator::update()`更新流体状态。
     - 遍历所有鱼类和小球，调用其`update()`方法更新位置。
   - **渲染阶段**：
     - 调用`Renderer::paintGL()`绘制场景。
   - **用户输入处理**：
     - 检测鼠标点击事件，创建新的小球。
     - 检测键盘输入，调整参数（如暂停/继续模拟）。

3. **退出**：
   - 释放资源，关闭程序。

---

### **4. 总结**

通过以上详细的开发流程和程序结构设计，你可以逐步实现这个项目。以下是几个关键点：

- **模块化设计**：将复杂的功能分解为多个独立的模块，每个模块专注于完成特定的任务。
- **数据驱动**：使用清晰的数据结构存储流体、物体的状态信息。
- **用户友好**：提供直观的用户界面，方便用户交互和调整参数。
- **性能优化**：对计算和渲染进行优化，确保实时性。